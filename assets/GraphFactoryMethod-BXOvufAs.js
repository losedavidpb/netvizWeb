import{G as M,V as E,E as y}from"./index-B9qRo6E7.js";class l extends M{read(t){if(t!==""){const e=t.split(/\r?\n/);let i=-1;if(e.forEach(n=>{if(n.length>=1){const a=M.split(n);if(!(i===-1||i===a.length))throw new Error("InvalidAdjacencyMatrix :: Adjacency Matrix must be simetric");if(!l.is_valid_adjacency_row(a))throw new Error("InvalidAdjacencyMatrix :: Adjacency Matrix must have binary values");this.edgeList.push(a),this.vertices.push(new E(0,0,0)),i=a.length}}),this.vertices.length!==i)throw new Error("InvalidAdjacencyMatrix :: Adjacency Matrix must be simetric");this.update_adjacency_matrix(),this.update_vertices(),this.update_edges()}}toString(){return this.vertices.length===0?"":this.adjacencyMatrix.map(t=>t.join(" ")).join(`
`)}static is_valid_adjacency_row(t){return t.every(e=>e===0||e===1)}update_adjacency_matrix(){for(let t=0;t<this.vertices.length;++t){this.adjacencyMatrix.push([]);for(let e=0;e<this.vertices.length;++e)this.adjacencyMatrix[t].push(this.edgeList[t][e])}}update_vertices(){for(let t=0;t<this.vertices.length;++t)for(let e=t;e<this.vertices.length;++e)if(this.adjacencyMatrix[t][e]===1){if(e==t)continue;this.vertices[t].attachPoint(this.vertices[e]),this.vertices[t].updateDegree(),this.vertices[e].updateDegree()}}update_edges(){this.edgeList=[];for(let t=0;t<this.vertices.length;++t)for(let e=0;e<t;++e)this.adjacencyMatrix[t][e]===1&&this.edgeList.push([e,t])}}const k="%%MatrixMarket";function A(s){const t=["","","",""];X(t);const e=s[0].trim().split(/\s+/);if(e.length!==5)return p;let[i,r,n,a,o]=e;if(!i.startsWith(k))return Y;r=r.toLowerCase(),n=n.toLowerCase(),a=a.toLowerCase(),o=o.toLowerCase();const c=it(r,n,a,o,t);return c||[t,1]}function L(s,t){let e="",i,r;do if(e=s[t++],t>=s.length)return p;while(e!=null&&e.startsWith("%"));let n=v(e);if(n!==null)return[i,r]=n,[i,r,t];for(;;){if(e=s[t++],t>=s.length)return p;if(n=v(e.trim()),n!==null)return[i,r]=n,[i,r,t]}}const G=s=>s[1]==="C",P=s=>s[2]==="P",C=s=>s[3]==="S",N=s=>s[0]="M",I=s=>s[1]="C",b=s=>s[1]="A",D=b,W=I,z=s=>s[2]="C",O=s=>s[2]="R",$=s=>s[2]="P",H=s=>s[2]="I",U=s=>s[3]="S",F=s=>s[3]="G",K=s=>s[3]="K",V=s=>s[3]="H",X=s=>{s[0]=" ",s[1]=" ",s[2]=" ",s[3]="G"},p=12,Y=14,_=15,B="matrix",q="array",Q="coordinate",Z="coordinate",J="complex",tt="real",R="integer",et="general",S="symmetric",rt="hermitian",st="skew-symmetric",T="pattern";function it(s,t,e,i,r){if(s!==B)return _;if(N(r),t===Z)W(r);else if(t===q)D(r);else return _;if(e===tt)O(r);else if(e===J)z(r);else if(e===T)$(r);else if(e===R)H(r);else return _;if(i===et)F(r);else if(i===S)U(r);else if(i===rt)V(r);else if(i===st)K(r);else return _}function v(s){const t=s.trim().split(/\s+/);if(t.length===3){const e=parseInt(t[0],10),i=parseInt(t[1],10),r=parseInt(t[2],10);if(![e,i,r].some(isNaN))return[{M:e,N:i},r]}return null}class j extends M{read(t){if(t!==""){const e=t.split(/\r?\n/),i=A(e);if(typeof i=="number")throw new Error("MatrixMarket :: Could not process Matrix Market banner.");const[r,n]=i;let a=n;if(!G(r)||!P(r)||!C(r))throw new Error(`MatrixMarket :: Sorry, this application only supports graphs that are:
	Matrix Market type: [`+Q+"]["+T+"]["+S+`]
	and not: [`+R+`]
`);const o=L(e,a);if(typeof o=="number")throw new Error("MatrixMarket :: Could not process Matrix Market size.");let c,d;[d,c,a]=o;const[m,u]=[d.M,d.N],f=new Array(c).fill(0),g=new Array(c).fill(0);for(let h=0;h<c;h++){const x=e[a++];if(x!=null){const w=x.trim().split(/\s+/);f[h]=parseInt(w[0],10)-1,g[h]=parseInt(w[1],10)-1}}this.init_adj_vertices(m,u),this.update_adj_vertices(c,f,g),this.update_edges(m,u)}}toString(){let t=`%%MatrixMarket matrix coordinate pattern symmetric
`;t+=`${this.vertices.length} ${this.vertices.length} ${this.edgeList.length}
`;const e=this.edgeList.map(([i,r])=>[Math.min(i,r),Math.max(i,r)]).sort(([i,r],[n,a])=>i-n||r-a);return t+=e.map(([i,r])=>`${i+1} ${r+1}`).join(`
`),t}init_adj_vertices(t,e){for(let i=0;i<t;++i){this.vertices.push(new E(0,0,0)),this.adjacencyMatrix.push([]);for(let r=0;r<e;++r)this.adjacencyMatrix[i].push(0)}}update_adj_vertices(t,e,i){for(let r=0;r<t;++r)e[r]!=i[r]&&(this.vertices[e[r]].attachPoint(this.vertices[i[r]]),this.vertices[e[r]].updateDegree(),this.vertices[i[r]].updateDegree(),this.adjacencyMatrix[e[r]][i[r]]=1,this.adjacencyMatrix[i[r]][e[r]]=1)}update_edges(t,e){this.edgeList=[];for(let i=0;i<t;++i)for(let r=i;r<e;++r)this.adjacencyMatrix[i][r]===1&&this.edgeList.push([i,r])}}class at{static create(t,e){if(t.length>=14&&t.startsWith("%%MatrixMarket"))return new j(e);if(t.length<=4)return new y(e);if(t.length>0&&(t.startsWith("0")||t.startsWith("1")))return new l(e);throw new Error("InvalidGraph :: Passed graph is not supported")}static createWithType(t){switch(t){case"AdjacencyGraph":return new l;case"EdgeGraph":return new y;case"MatrixMarketGraph":return new j;default:throw new Error("InvalidGraph :: Passed graph is not supported")}}}export{at as GraphFactoryMethod};
